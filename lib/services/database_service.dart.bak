import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:habits_timer/models/activity.dart';
import 'package:habits_timer/models/session.dart';
import 'package:habits_timer/models/pause.dart';

/// Service en mémoire (pas encore SQLite).
/// Objectif: faire tourner l'app (création, ouverture, start/stop, mini stats).
/// On migrera vers SQLite dans le palier 3.
class DatabaseService {
  // Singleton simple
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  // --- STOCKAGE EN MÉMOIRE ---
  final List<Activity> _activities = [];
  final List<Session> _sessions = [];
  final List<Pause> _pauses = [];

  int _nextActivityId = 1;
  int _nextSessionId = 1;
  int _nextPauseId = 1;

  // ---------- ACTIVITIES ----------
  Future<List<Activity>> getAllActivities() async {
    // renvoie une copie pour éviter les mutations externes
    return List<Activity>.unmodifiable(_activities);
  }

  Future<Activity> addActivity(Activity a) async {
    final withId = Activity(
      id: _nextActivityId++,
      name: a.name,
      emoji: a.emoji,
      color: a.color,
      goalMinutesPerDay: a.goalMinutesPerDay,
      goalMinutesPerWeek: a.goalMinutesPerWeek,
      goalMinutesPerMonth: a.goalMinutesPerMonth,
      goalMinutesPerYear: a.goalMinutesPerYear,
    );
    _activities.add(withId);
    return withId;
  }

  Future<Activity?> getActivity(int id) async {
    try {
      return _activities.firstWhere((x) => x.id == id);
    } catch (_) {
      return null;
    }
  }

  Future<Activity?> updateActivity(Activity a) async {
    if (a.id == null) return null;
    final idx = _activities.indexWhere((x) => x.id == a.id);
    if (idx == -1) return null;
    _activities[idx] = a;
    return a;
  }

  Future<int> deleteActivity(int id) async {
    final before = _activities.length;
    _activities.removeWhere((x) => x.id == id);
    // on supprime aussi les sessions liées (et pauses)
    _sessions.removeWhere((s) => s.activityId == id);
    final removedPausesIds = _sessions.map((s) => s.id).toSet();
    _pauses.removeWhere((p) => removedPausesIds.contains(p.sessionId));
    return before - _activities.length;
  }

  // ---------- SESSIONS ----------
  Future<Session?> getRunningSession(int activityId) async {
    try {
      return _sessions.firstWhere(
            (s) => s.activityId == activityId && s.endAt == null,
      );
    } catch (_) {
      return null;
    }
  }

  Future<Session> startSession(int activityId) async {
    // Si une session est déjà en cours pour cette activité, on renvoie celle-là
    final running = await getRunningSession(activityId);
    if (running != null) return running;

    final now = DateTime.now();
    final s = Session(
      id: _nextSessionId++,
      activityId: activityId,
      startAt: now,
      endAt: null,
    );
    _sessions.add(s);
    return s;
  }

  /// Pause/Unpause: si une pause en cours -> la terminer, sinon en démarrer une.
  Future<Pause?> togglePauseByActivity(int activityId) async {
    final running = await getRunningSession(activityId);
    if (running == null) return null;
    return togglePause(running.id);
  }

  Future<Pause?> togglePause(int sessionId) async {
    // y a-t-il une pause ouverte ?
    final open = _pauses.where((p) => p.sessionId == sessionId && p.endAt == null);
    if (open.isNotEmpty) {
      // on clôt la pause
      final p = open.first;
      final updated = Pause(
        id: p.id,
        sessionId: p.sessionId,
        startAt: p.startAt,
        endAt: DateTime.now(),
      );
      final idx = _pauses.indexWhere((x) => x.id == p.id);
      _pauses[idx] = updated;
      return updated;
    } else {
      // on ouvre une nouvelle pause
      final newP = Pause(
        id: _nextPauseId++,
        sessionId: sessionId,
        startAt: DateTime.now(),
        endAt: null,
      );
      _pauses.add(newP);
      return newP;
    }
  }

  Future<Session?> stopSessionByActivity(int activityId) async {
    final running = await getRunningSession(activityId);
    if (running == null) return null;
    return stopSession(running.id);
  }

  Future<Session?> stopSession(int sessionId) async {
    try {
      final s = _sessions.firstWhere((x) => x.id == sessionId);
      if (s.endAt != null) return s; // déjà stoppée
      final updated = Session(
        id: s.id,
        activityId: s.activityId,
        startAt: s.startAt,
        endAt: DateTime.now(),
      );
      final idx = _sessions.indexWhere((x) => x.id == s.id);
      _sessions[idx] = updated;
      return updated;
    } catch (_) {
      return null;
    }
  }

  // ---------- QUERIES ----------
  Future<List<Session>> getSessionsForActivity(int activityId) async {
    return _sessions
        .where((s) => s.activityId == activityId)
        .toList(growable: false)
      ..sort((a, b) => (b.startAt).compareTo(a.startAt));
  }

  Future<List<Session>> getSessionsBetween(
      DateTime start,
      DateTime end, {
        int? activityId,
      }) async {
    final list = _sessions.where((s) {
      final sEnd = s.endAt ?? DateTime.now();
      final overlap =
          (s.startAt.isBefore(end) || s.startAt.isAtSameMomentAs(end)) &&
              (sEnd.isAfter(start) || sEnd.isAtSameMomentAs(start));
      return overlap && (activityId == null || s.activityId == activityId);
    }).toList(growable: false);
    list.sort((a, b) => a.startAt.compareTo(b.startAt));
    return list;
  }

  // Durée active d’une session, en minutes (pauses soustraites)
  int _activeMinutes(Session s) {
    final end = s.endAt ?? DateTime.now();
    var total = end.difference(s.startAt).inMinutes;
    // Soustraire les pauses de cette session
    final pauses = _pauses.where((p) => p.sessionId == s.id);
    for (final p in pauses) {
      final pEnd = p.endAt ?? DateTime.now();
      total -= pEnd.difference(p.startAt).inMinutes;
    }
    return total < 0 ? 0 : total;
  }

  Future<int> minutesForDay(DateTime day, int activityId) async {
    final start = DateTime(day.year, day.month, day.day);
    final end = start.add(const Duration(days: 1));
    final sess = await getSessionsBetween(start, end, activityId: activityId);
    return sess.fold<int>(0, (sum, s) => sum + _activeMinutes(s));
  }

  Future<int> minutesForWeek(DateTime anchor, int activityId) async {
    // Lundi comme début de semaine
    final dayOfWeek = (anchor.weekday + 6) % 7; // 0 lundi … 6 dimanche
    final start = DateTime(anchor.year, anchor.month, anchor.day).subtract(Duration(days: dayOfWeek));
    final end = start.add(const Duration(days: 7));
    final sess = await getSessionsBetween(start, end, activityId: activityId);
    return sess.fold<int>(0, (sum, s) => sum + _activeMinutes(s));
  }

  /// 24 buckets (0..23) de minutes actives pour un jour donné
  Future<List<int>> hourlyActiveMinutes(DateTime day, int activityId) async {
    final start = DateTime(day.year, day.month, day.day);
    final end = start.add(const Duration(days: 1));
    final sess = await getSessionsBetween(start, end, activityId: activityId);

    final buckets = List<int>.filled(24, 0);
    for (final s in sess) {
      // on itère minute par minute pour bucketiser (simple mais suffisant ici)
      var from = s.startAt.isBefore(start) ? start : s.startAt;
      final until = (s.endAt ?? DateTime.now()).isAfter(end) ? end : (s.endAt ?? DateTime.now());

      // enlève les périodes en pause
      final pauses = _pauses.where((p) => p.sessionId == s.id).toList();
      DateTime cursor = from;

      // Fonction utilitaire pour ajouter minutes actives entre [a,b[
      void addRange(DateTime a, DateTime b) {
        var t = a;
        while (t.isBefore(b)) {
          final hour = t.hour;
          buckets[hour] += 1;
          t = t.add(const Duration(minutes: 1));
        }
      }

      // On déduit chaque pause
      for (final p in pauses) {
        final pFrom = p.startAt.isBefore(start) ? start : p.startAt;
        final pTo = (p.endAt ?? DateTime.now()).isAfter(end) ? end : (p.endAt ?? DateTime.now());
        if (pTo.isAfter(pFrom)) {
          // ajouter temps actif avant la pause
          if (pFrom.isAfter(cursor)) addRange(cursor, pFrom);
          // sauter la pause
          cursor = pTo.isAfter(cursor) ? pTo : cursor;
        }
      }
      // Finir la partie après la dernière pause
      if (until.isAfter(cursor)) addRange(cursor, until);
    }
    return buckets;
  }

  // ---------- EXPORT / RESET (stub pour le moment) ----------
  Future<String> exportJson() async {
    final data = {
      'activities': _activities.map((a) => a.toMap()).toList(),
      'sessions': _sessions.map((s) => s.toMap()).toList(),
      'pauses': _pauses.map((p) => p.toMap()).toList(),
    };
    return jsonEncode(data);
  }

  // (Optionnel) on implémentera l’import plus tard
  Future<void> importJson(String content) async {
    final map = jsonDecode(content) as Map<String, dynamic>;
    // nettoyage
    _activities.clear();
    _sessions.clear();
    _pauses.clear();
    _nextActivityId = 1;
    _nextSessionId = 1;
    _nextPauseId = 1;

    final acts = (map['activities'] as List?) ?? [];
    for (final m in acts) {
      final a = Activity.fromMap(Map<String, dynamic>.from(m));
      _activities.add(a);
      _nextActivityId = a.id != null ? (_nextActivityId > a.id! ? _nextActivityId : a.id! + 1) : _nextActivityId;
    }

    final sess = (map['sessions'] as List?) ?? [];
    for (final m in sess) {
      final s = Session.fromMap(Map<String, dynamic>.from(m));
      _sessions.add(s);
      _nextSessionId = _nextSessionId > s.id ? _nextSessionId : s.id + 1;
    }

    final paus = (map['pauses'] as List?) ?? [];
    for (final m in paus) {
      final p = Pause.fromMap(Map<String, dynamic>.from(m));
      _pauses.add(p);
      _nextPauseId = _nextPauseId > p.id ? _nextPauseId : p.id + 1;
    }
  }

  Future<void> resetDatabase() async {
    _activities.clear();
    _sessions.clear();
    _pauses.clear();
    _nextActivityId = 1;
    _nextSessionId = 1;
    _nextPauseId = 1;
  }

  // Pour la page settings (stub)
  Future<String> databasePath() async => 'in-memory';
  // === Stats helpers ajoutés par Palier B ===
  DateTime _startOfDay(DateTime d) => DateTime(d.year, d.month, d.day);

  Duration _effectiveInRange({
    required DateTime rangeStart,
    required DateTime rangeEnd,
    required DateTime sessionStart,
    required DateTime? sessionEnd,
    required List<(DateTime start, DateTime? end)> pauses,
  }) {
    final s = sessionStart.isAfter(rangeStart) ? sessionStart : rangeStart;
    final e = (sessionEnd ?? DateTime.now()).isBefore(rangeEnd)
        ? (sessionEnd ?? DateTime.now())
        : rangeEnd;
    if (!e.isAfter(s)) return Duration.zero;

    var active = e.difference(s);
    for (final p in pauses) {
      final ps = p.$1.isAfter(rangeStart) ? p.$1 : rangeStart;
      final pe = (p.$2 ?? DateTime.now()).isBefore(rangeEnd) ? (p.$2 ?? DateTime.now()) : rangeEnd;
      final overlapStart = ps.isAfter(s) ? ps : s;
      final overlapEnd = pe.isBefore(e) ? pe : e;
      if (overlapEnd.isAfter(overlapStart)) {
        active -= overlapEnd.difference(overlapStart);
      }
    }
    return active.isNegative ? Duration.zero : active;
  }

  Future<int> minutesForActivityOnDay(String activityId, DateTime day) async {
    final from = _startOfDay(day);
    final to   = _startOfDay(day.add(const Duration(days: 1)));
    final sessions = await getSessionsByActivity(activityId);
    int minutes = 0;
    for (final s in sessions) {
      final pauses = await getPausesBySession(s.id);
      final dur = _effectiveInRange(
        rangeStart: from,
        rangeEnd: to,
        sessionStart: s.startAt,
        sessionEnd: s.endAt,
        pauses: pauses.map((p) => (p.startAt, p.endAt)).toList(),
      );
      minutes += dur.inMinutes;
    }
    return minutes;
  }

  Future<List<DailyStat>> last7DaysStats(String activityId) async {
    final today = DateTime.now();
    final start = _startOfDay(today.subtract(const Duration(days: 6)));
    final days = List.generate(7, (i) => _startOfDay(start.add(Duration(days: i))));
    final result = <DailyStat>[];
    for (final d in days) {
      final m = await minutesForActivityOnDay(activityId, d);
      result.add(DailyStat(day: d, minutes: m));
    }
    return result;
  }

  Future<List<HourlyBucket>> hourlyDistribution(String activityId, DateTime day) async {
    final from = _startOfDay(day);
    final to = _startOfDay(day.add(const Duration(days: 1)));
    final buckets = List.generate(24, (h) => HourlyBucket(hour: h, minutes: 0));
    final sessions = await getSessionsByActivity(activityId);

    for (final s in sessions) {
      final pauses = await getPausesBySession(s.id);
      final effStart = s.startAt.isAfter(from) ? s.startAt : from;
      final effEnd = (s.endAt ?? DateTime.now()).isBefore(to) ? (s.endAt ?? DateTime.now()) : to;
      if (!effEnd.isAfter(effStart)) continue;

      for (var t = effStart; t.isBefore(effEnd); t = t.add(const Duration(minutes: 1))) {
        final inPause = pauses.any((p) {
          final ps = p.startAt;
          final pe = p.endAt ?? DateTime.now();
          return !t.isBefore(ps) && t.isBefore(pe);
        });
        if (inPause) continue;
        final h = t.hour;
        buckets[h] = HourlyBucket(hour: h, minutes: buckets[h].minutes + 1);
      }
    }
    return buckets;
  }
  // === Fin helpers Palier B ===  // === Stats helpers ajoutés par Palier B ===
  DateTime _startOfDay(DateTime d) => DateTime(d.year, d.month, d.day);

  Duration _effectiveInRange({
    required DateTime rangeStart,
    required DateTime rangeEnd,
    required DateTime sessionStart,
    required DateTime? sessionEnd,
    required List<(DateTime start, DateTime? end)> pauses,
  }) {
    final s = sessionStart.isAfter(rangeStart) ? sessionStart : rangeStart;
    final e = (sessionEnd ?? DateTime.now()).isBefore(rangeEnd)
        ? (sessionEnd ?? DateTime.now())
        : rangeEnd;
    if (!e.isAfter(s)) return Duration.zero;

    var active = e.difference(s);
    for (final p in pauses) {
      final ps = p.$1.isAfter(rangeStart) ? p.$1 : rangeStart;
      final pe = (p.$2 ?? DateTime.now()).isBefore(rangeEnd) ? (p.$2 ?? DateTime.now()) : rangeEnd;
      final overlapStart = ps.isAfter(s) ? ps : s;
      final overlapEnd = pe.isBefore(e) ? pe : e;
      if (overlapEnd.isAfter(overlapStart)) {
        active -= overlapEnd.difference(overlapStart);
      }
    }
    return active.isNegative ? Duration.zero : active;
  }

  Future<int> minutesForActivityOnDay(String activityId, DateTime day) async {
    final from = _startOfDay(day);
    final to   = _startOfDay(day.add(const Duration(days: 1)));
    final sessions = await getSessionsByActivity(activityId);
    int minutes = 0;
    for (final s in sessions) {
      final pauses = await getPausesBySession(s.id);
      final dur = _effectiveInRange(
        rangeStart: from,
        rangeEnd: to,
        sessionStart: s.startAt,
        sessionEnd: s.endAt,
        pauses: pauses.map((p) => (p.startAt, p.endAt)).toList(),
      );
      minutes += dur.inMinutes;
    }
    return minutes;
  }

  Future<List<DailyStat>> last7DaysStats(String activityId) async {
    final today = DateTime.now();
    final start = _startOfDay(today.subtract(const Duration(days: 6)));
    final days = List.generate(7, (i) => _startOfDay(start.add(Duration(days: i))));
    final result = <DailyStat>[];
    for (final d in days) {
      final m = await minutesForActivityOnDay(activityId, d);
      result.add(DailyStat(day: d, minutes: m));
    }
    return result;
  }

  Future<List<HourlyBucket>> hourlyDistribution(String activityId, DateTime day) async {
    final from = _startOfDay(day);
    final to = _startOfDay(day.add(const Duration(days: 1)));
    final buckets = List.generate(24, (h) => HourlyBucket(hour: h, minutes: 0));
    final sessions = await getSessionsByActivity(activityId);

    for (final s in sessions) {
      final pauses = await getPausesBySession(s.id);
      final effStart = s.startAt.isAfter(from) ? s.startAt : from;
      final effEnd = (s.endAt ?? DateTime.now()).isBefore(to) ? (s.endAt ?? DateTime.now()) : to;
      if (!effEnd.isAfter(effStart)) continue;

      for (var t = effStart; t.isBefore(effEnd); t = t.add(const Duration(minutes: 1))) {
        final inPause = pauses.any((p) {
          final ps = p.startAt;
          final pe = p.endAt ?? DateTime.now();
          return !t.isBefore(ps) && t.isBefore(pe);
        });
        if (inPause) continue;
        final h = t.hour;
        buckets[h] = HourlyBucket(hour: h, minutes: buckets[h].minutes + 1);
      }
    }
    return buckets;
  }
  // === Fin helpers Palier B ===}


